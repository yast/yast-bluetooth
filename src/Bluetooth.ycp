/**
 * File:	modules/Bluetooth.ycp
 * Package:	Configuration of bluetooth
 * Summary:	Bluetooth settings, input and output functions
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of bluetooth devices.
 * Input and output routines.
 */

{

module "Bluetooth";
textdomain "bluetooth";

import "Progress";
import "Report";
import "Summary";
import "Service";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}


// global bluetooth setting
global boolean enabled = false;

// is authentification enabled?
global boolean authentification = false;

// is encryption enabled?
global boolean encryption = false;

// can other detect bluetooth devices?
global boolean inquiry_scan = false;

// can other connect to bluetooth devices?
global boolean page_scan = false;

// bluetooth daemons configarion
global list<map<string,any> > daemons = [];

// PIN number
global string pin = "";


define list<string> detect_services(list<string> all) ``{
    list<string> ret = [];

    if (all != nil && size(all) > 0)
    {
	foreach(string var, all, ``{
		if (regexpmatch(var, ".*_START$"))
		{
		    string daemon_name = regexpsub(var, "(.*)_START$", "\\1");
		    ret = add(ret, daemon_name);
		}
	    }
	);
    }

    return ret;
}

/**
 * Read all bluetooth settings
 * @return true on success
 */
global boolean Read() {
    // read sysconfig settings
    // read global setting
    enabled = (SCR::Read(.sysconfig.bluetooth.START_SERVICES) == "yes");
    y2milestone("bluetooth enabled: %1", enabled);

    // search for all daemon variables
    list<string> dir = (list<string>) SCR::Dir(.sysconfig.bluetooth);
    y2debug("detected variables: %1", dir);

    list<string> detected_services = detect_services(dir);
    y2debug("detected services: %1", detected_services);

    // reset daemon list
    daemons = [];
    foreach(string service, detected_services, ``{
	    // read start status
	    boolean service_enabled = (SCR::Read(.sysconfig.bluetooth + (service + "_START")) == "yes");

	    // read path to daemon binary
	    string binary = (string)SCR::Read(.sysconfig.bluetooth + (service + "_DAEMON"));

	    // read daemon arguments
	    string args = (string)SCR::Read(.sysconfig.bluetooth + (service + "_DAEMON_ARGS"));

	    daemons = add(daemons, $[ "service" : service, "enabled" : service_enabled,
		"daemon" : binary, "args" : args ]);
	}
    );
    y2milestone("configuration of daemons: %1", daemons);

    // read hcid.conf settings
    // read security settings
    authentification = (SCR::Read(.bluetooth.hcid.value.device.auth) == ["enable"]);
    y2milestone("authentification: %1", authentification);
    encryption= (SCR::Read(.bluetooth.hcid.value.device.encrypt) == ["enable"]);
    y2milestone("encryption: %1", encryption);

    // read scan settings
    inquiry_scan = (SCR::Read(.bluetooth.hcid.value.device.iscan) == ["enable"]);
    y2milestone("inquiry_scan: %1", inquiry_scan);
    page_scan = (SCR::Read(.bluetooth.hcid.value.device.pscan) == ["enable"]);
    y2milestone("page_scan: %1", page_scan);

    // read PIN
    list<string> p = splitstring((string)SCR::Read(.target.string, "/etc/bluetooth/pin"), "\n");
    pin = p[0]:"";

    return true;
}

/**
 * Write all bluetooth settings
 * @return true on success
 */
global boolean Write() {

    /* Bluetooth read dialog caption */
    string caption = _("Saving Bluetooth Configuration");

    integer steps = 2;

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Restart Bluetooth Service")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Restarting Bluetooth Service..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    Progress::NextStage();

    // write global settings
    SCR::Write(.sysconfig.bluetooth.START_SERVICES, (enabled) ? "yes" : "no");

    // write daemon settings
    foreach(map<string,any> d, daemons, ``{
	    SCR::Write(.sysconfig.bluetooth + ((d["service"]:"") + "_START"), d["enabled"]:false ? "yes" : "no");
	    SCR::Write(.sysconfig.bluetooth + ((d["service"]:"") + "_DAEMON_ARGS"), d["args"]:"");
	}
    );

    // write hcid.conf settings
    SCR::Write(.bluetooth.hcid.value.device.auth, [authentification ? "enable" : "disable"]);
    SCR::Write(.bluetooth.hcid.value.device.encrypt, [encryption ? "enable" : "disable"]);
    SCR::Write(.bluetooth.hcid.value.device.iscan, [inquiry_scan ? "enable" : "disable"]);
    SCR::Write(.bluetooth.hcid.value.device.pscan, [page_scan ? "enable" : "disable"]);

    // write PIN
    SCR::Write(.target.string, "/etc/bluetooth/pin", pin);

    // flush changes
    SCR::Write(.bluetooth.hcid, nil);
    SCR::Write(.sysconfig.bluetooth, nil);


    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */

    // activate bluetooth service if needed
    if (enabled && !Service::Enabled("bluetooth"))
    {
	y2milestone("Enabling bluetooth service...");
	boolean res = Service::Enable("bluetooth");
	y2milestone("Enabled: %1", res);
    }

    // restart service
    if (!write_only)
    {
	Service::Restart("bluetooth");
    }

    /* Progress finished */
    Progress::NextStage();

    return true;
}

/**
 * Get all bluetooth settings from map
 * (For use by autoinstallation.)
 * @param settings map to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    enabled = settings["enabled"]:false;
    authentification = settings["authentification"]:false;
    encryption = settings["encryption"]:false;
    inquiry_scan = settings["inquiry_scan"]:false;
    page_scan = settings["page_scan"]:false;
    daemons = settings["daemons"]:[];
    pin = settings["pin"]:"";

    return true;
}

/**
 * Dump the bluetooth settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    return $[
	"enabled" : enabled,
	"authentification" : authentification,
	"encryption" : encryption,
	"inquiry_scan" : inquiry_scan,
	"page_scan" : page_scan,
	"daemons" : daemons,
	"pin" : pin
    ];
}

global void Propose() {
    // read settings
    Read();

    // was detected bluetooth adapter?
    boolean detected = false;

    // start bluetooth service
    Service::Start("bluetooth");

    // query local bluetooth devices (adapters)
    map<string,any> out = (map<string,any>)SCR::Execute(.target.bash_output, "/usr/bin/hcitool dev");

    if (out["exit"]:-1 == 0)
    {
	list<string> devs = splitstring(out["stdout"]:"", "\n");
	y2debug("devs: %1", devs);

	// if output has more than 2 line then a local bluetooth device was found
	// (there is a header on the firast line and empty line at the end)
	detected = size(devs) > 2;
    }

    // stop bluetooth service
    Service::Stop("bluetooth");

    // set enabled/disabled status depending on found bluetooth adapters
    enabled = detected;
}

/**
 * Create a textual summary of configuration
 * @return summary of the current configuration
 */
global string Summary() {
    /* Configuration summary text */

    // status string
    string status = (enabled) ? _("Enabled") : _("Disabled");

    string ret = sformat("<ul><li>%1</li>", status);

    if (enabled)
    {
	// add list of enabled services
	string enabled_daemons = "";

	foreach(map<string,any> d, daemons, ``{
		string dname = d["service"]:"";

		if (d["enabled"]:false == true)
		{
		    if (enabled_daemons != "")
		    {
			enabled_daemons = enabled_daemons + ", ";
		    }

		    enabled_daemons = enabled_daemons + dname;
		}
	    }
	);

	if (enabled_daemons == "")
	{
	    // no daemon is enabled, appended to string "Started services: "
	    enabled_daemons = _("<I>None</I>");
	}

	// status string, %1 is replaced by list of daemons (e.g. "HCI, SDP, PAND") or "none"
	ret = ret + sformat(_("<li>Started services: %1</li>"), enabled_daemons);
    }

    ret = ret + "</ul>";

    return ret;
}


/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
